<div>
										<div style="width: 600px; float: left;">
											<label for="chooseNode" >Choose Ingredient:</label>
											<select id="chooseNode"></select>
											<p> </p>
											<div>
												<div style="width: 50px; float: left;">Zoom: </div>
												<div style="margin-left: 50px;">
													<div id="vslider" style="width: 300px; height: 6px;"></div>	
												</div>
											</div>
											<p> </p>
											<div>
												<div style="width: 50px; float: left;">Degree: </div>
												<div style="margin-left: 50px;">
													<div id="vdegslider" style="width: 300px; height: 6px;"></div>	
												</div>
											</div>
											<p> </p>
											<div>
												<div style="width: 50px; float: left;">Weight: </div>
												<div style="margin-left: 50px;">
													<div id="vwtslider" style="width: 300px; height: 6px;"></div>	
												</div>
											</div>
											<p> </p>
										</div>
										<div style="margin-left: 500px;" >
											<ul class="check-list">
												<li>Pick an ingredient to see its culinary network. </li>
												<li>Use slider to zoom in/out of network. </li>
												<li>(Shift) double-click on a node to zoom (out)in. </li>
											</ul>
										</div>
									</div>

			<div id="chart"> </div>
						<script>
							var color = d3.scale.category20();

							var width = 1000,
							height = 1000;

							var cuisine = getQueryVariable("cuisine");
							var jsonFile = "ingredientNets/data/" + cuisine + ".json";

							var maxDegree = 0 ;
							var minDegree = 0;
							var maxEdgeWeight = 0;
							var minEdgeWeight = 0;
							var degreeThreshold = 0;
							var edgeThreshold = 0;

							d3.json(jsonFile, function(error, json) {
								json.nodes.forEach(function(d) {
								if (d.id ){
									if (d.degree > maxDegree){
										maxDegree = d.degree;
									}
									if(d.degree < minDegree) {
										minDegree = d.minDegree;
									}
								}
								});
								json.links.forEach(function (d) {
									if (d.value > maxEdgeWeight){
										maxEdgeWeight = d.value;
									}
									if (d.value < minEdgeWeight){
										minEdgeWeight = d.value;
									}
								});

								eightyPercent = (maxDegree - minDegree)*0.80;

							});
							$(function() {
							$( "#vslider" ).slider({
								orientation: "horizontal",
								range: "min",
								min: 900,
								max: 10000,
								value: 1000,
								slide: function( event, ui ) {
									zoomWithSlider(ui.value/1000);
								}
							});
							});
							function zoomWithSlider(scale) {
								var svg = d3.select("#chart").select("svg");
								var container = svg.select("g");
								var h = svg.attr("height"), w = svg.attr("width");

								// Note: works only on the <g> element and not on the <svg> element
								// which is a common mistake
								container.attr("transform",
										"translate(" + w/2 + ", " + h/2 + ") " +
										"scale(" + scale + ") " +
										"translate(" + (-w/2) + ", " + (-h/2) + ")");
							}

							$(function() {
							$( "#vdegslider" ).slider({
								orientation: "horizontal",
								range: "min",
								min: 0,
								max: 10,
								value: 1,
								slide: function( event, ui ) {
									adjustDegreeWithSlider(ui.value/9);
								}
							});
							});
							function adjustDegreeWithSlider(scale) {
								degreeThreshold = (maxDegree - minDegree)*scale + minDegree;
								d3.selectAll('circle')
									.style("fill", function(d, i) { 
										if(d.degree > degreeThreshold) {
											return color(d.degree);
										}
										else { return  "#999"; }  

									});
							}
							$(function() {
							$( "#vwtslider" ).slider({
								orientation: "horizontal",
								range: "min",
								min: 0,
								max: 10,
								value: 1,
								slide: function( event, ui ) {
									adjustEdgeWithSlider(ui.value/9);
								}
							});
							});
							function adjustEdgeWithSlider(scale) {
								edgeThreshold = (maxEdgeWeight - minEdgeWeight)*scale + minEdgeWeight;
								console.log(edgeThreshold);		
							}

							var svg = d3.select("#chart")
							.append("svg:svg")
							.attr("width", width)
							.attr("height", height)
							.attr("pointer-events", "all")
							.append('svg:g')
							.call(d3.behavior.zoom().on("zoom", redraw))
							.append('svg:g');


							svg.append('svg:rect')
							.attr('width', width)
							.attr('height', height)
							.attr('fill', 'white');

							function redraw() {
								console.log("here", d3.event.translate, d3.event.scale);
								svg.attr("transform",
										"translate(" + d3.event.translate + ")"
										+ " scale(" + d3.event.scale + ")");
							}


							var force = d3.layout.force()
								.distance(500)
								.gravity(0)
								.friction(1)
								.size([width, height]);
							d3.json(jsonFile, function(error, json) {
								force.nodes(json.nodes)
								.links(json.links);			
								setTimeout(function() {
										var n = 400
										force.start();
										for (var i = n * n; i > 0; --i) force.tick();
										force.stop();

										var link = svg.selectAll(".link")
										.data(json.links)
										.enter().append("line")
										.attr("class", "link")
										.attr("x1", function(d) { return d.source.x; })
										.attr("y1", function(d) { return d.source.y; })
										.attr("x2", function(d) { return d.target.x; })
										.attr("y2", function(d) { return d.target.y; })
										.style("stroke", "#fff");
										var node = svg.selectAll(".node")
										.data(json.nodes)
										.enter().append("g")
										.attr("class", "node")
										.on("mouseover", fade(.1))
										.on("mouseout", fade(1))
										.attr("cx", function(d) { return d.x; })
										.attr("cy", function(d) { return d.y; })
										.attr("r", 4.5);
										node.append("circle")
											.attr("r", function(d) { return Math.sqrt(d.degree+1)*1.1; })
											.style("fill", function(d) { return color(d.degree+1); })
											.attr("cx", function(d) { return d.x; })
											.attr("cy", function(d) { return d.y; });

										node.append("text")
											.attr("dx", 12 )
											.attr("dy", "0.35em" )
											.attr("font-size",11)
											.style('font-weight', 'bold');

										svg.style("opacity", 1e-6)
											.transition()
											.duration(1000)
											.style("opacity", 1);

										var nodesByIndex = new Array();
										json.nodes.forEach(function(d) {
											if (d.id && d.id.toLowerCase() != 'all'){
												nodesByIndex.push(d);
												
											}
										});

										console.log(nodesByIndex);
										//dropDownNodes.push(d.id.toLowerCase());
										//sort the nodes by degree - orderedNodes will contain the new order
										orderedNodes =  nodesByIndex.sort(function(a,b) { return a.degree - b.degree; });

										console.log(orderedNodes);
										//dropDownNodes.sort()
										//dropDownNodes.unshift("all");

										oldNodes = nodesByIndex;
										nodesByIndex = new Array();
										var dropDownNodes = new Array();
										for (var i=0; i<orderedNodes.length; i++){
											index = orderedNodes[i];
											nodesByIndex.push(orderedNodes[i]);
											dropDownNodes.push(orderedNodes[i].id.toLowerCase());
										}

										var linkedByIndex = {};
										var nodesByName = {};
										json.links.forEach(function (d) {
												linkedByIndex[d.source.index + "," + d.target.index] = 1;
												nodesByName[d.source.id] = d.source;
												nodesByName[d.target.id] = d.target;
										});
										function isConnected(a,b){
											return linkedByIndex[a.index+ "," + b.index] || linkedByIndex[b.index + "," + a.index] || a.index == b.index;
										}
										// Build the dropdown menu
										var dropDown = d3.select("#chooseNode")
										    .on("change", function() {
												nodeId = this.selectedIndex;
												d3.selectAll('circle')
												.style("fill", function(d, i) { 
													if(nodeId ==  0){
														return  color(d.degree);
													}
													else {
														if(d.id.toLowerCase() == nodesByIndex[nodeId].id) {
															return "#000";
														}
														else if(isConnected(d, nodesByIndex[nodeId])) {
															return color(d.degree);
														}
														else { return  "#999"; }  
													}
												});
												

											})
										    .selectAll("option")
										    .data(dropDownNodes)
										    .enter()
										    .append("option")
										    .attr("value", function(d) { return d;} )
										    .text(function(d) {return d;});

										    function fade(opacity){
											    return function (d) {
												    node.style("stroke-opacity", function(o) {
														    thisOpacity = isConnected(d, o) ? 1: opacity;
														    this.setAttribute('fill-opacity', thisOpacity);
														    return thisOpacity;
														    });
												    link.style ("stroke-opacity", function(o) {
														    return o.value >= edgeThreshold && ( o.source === d || o.target === d )? 1: opacity;
														    });
												    link.style ("stroke", function(o) {
														    return opacity === 0.1 && o.value >= edgeThreshold ? (o.source === d || o.target === d ? "#000": "#fff") : "#fff";
														    });
												    d3.select(this).select("text").text(function() { 
														    return opacity === 0.1 && d.degree >= degreeThreshold ? d.id.toLowerCase() : "";
														    });
												    d3.selectAll(".node").filter(function(o){
														    return isConnected(o, d) == 1;
														    }).select("text").text(function(o) {
															    return opacity === 0.1 ? o.id.toLowerCase() : "";
															    })
															.attr("dx", function(o){ if (o.degree >= degreeThreshold){ return o.x + 12;} } )
															.attr("dy", function(o){ if (o.degree >= degreeThreshold){ return o.y + 6; } } );
					

											    };
										    }


									}, 10);
								});
						</script>
				
